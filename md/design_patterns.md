## View 객체와 ViewController 객체 사이 이벤트/데이터 전달을 위한 구조(디자인 패턴)
### 좋은 아키텍처란?
#### 각각의 객체는 구체적이고 명확한 역할 수행
- 관심사를 분리한다. (separation of concern)
- 객체는 대부분의 경우, 하나의 역할만 담당해야 한다.
- 객체들 사이의 관계를 설정하기 위한 coordinator 역할을 수행하는 클래스가 필요할 때도 있다.

#### 단순한 데이터 흐름
- 여러 개의 다른 객체들 사이를 왔다갔다 하는 구조는 피해야 한다.
- 특히, 공유자원을 조작해서 사용하는 경우 오류원인을 찾기 힘들다.
- 데이터는 단방향 흐름(uni-directional data flow)가 좋다.
    - 특정 지점에 브레이크를 설정하고 데이터에 어떤 변화가 일어나는 지 확인 가능하기 때문.

#### 유연해야 한다.
- 필요 이상으로 복잡하지 않고, 단순해야 한다.
- 특정 프레임워크나 서비스에 종속되지 않아야 한다.
- 프레임워크/서비스와 내가 작성한 코드 사이에 간단한 추상화 계층이 필요하다. 없는 경우, 발생하는 종속성이 큰 어려움을 초래한다.
- 예를 들어 프레임워크 또는 서비스가 종료될 때 문제 발생

#### 테스트가 용이해야 한다.
- TDD 방식으로 테스트 코드를 먼저 작성하면, 아키텍처, 클래스, 매니저 등을 구현하기 전에 API를 디자인할 수 있다.
- 첫 번째 테스트 코드를 작성하면서 어떻게 사용할 것인지 생각하며 함수를 작성한다. 즉, API 사용자 관점에서 코드를 작성한다.

### 인기있는 아키텍처 패턴들
- **MVC**: UI 패턴에 가깝다.
- **VIPER**
    - Interactor: 비즈니스 로직
        - composition을 사용하는 다른 서비스와 연동됨
    - Router: 뷰와 뷰 컨트롤러에 다른 프리젠테이션 컨텍스트 적용 가능하며, 이를 이용해 같은 화면을 여러 곳에 제공 가능
    - Presenter: UIKit과는 독립적인 프리젠테이션 로직 포함하는 클래스로, UIkit을 사용하지 않으면서 화면에 나타낼 데이터에 대한 포맷 구성과 같은 작업을 담당
    - 단점: 좋은 패턴이지만 수많은 기반 코드를 생성해야 하므로, 필요한 모듈들을 생성해주는 code generator 같은 도구를 사용하는 것이 일반적
- **MVVM**: iOS에서 가장 인기있는 패턴
    - 뷰컨트롤러도 뷰로 분류됨 (가장 중요)
        - 뷰 라이프사이클과 강력하게 연결돼 있으므로 뷰컨트롤러는 뷰 계층으로 분류
    - ViewModel는 테스트 가능
        - ViewModel에는 UIKit과 관련된 코드가 없다. 따라서 뷰컨트롤러 로딩과 의존성이 없으므로 ViewModel을 이용하여 비즈니스 로직을 테스트할 수 있다.
    - 단점: 바인딩을 도와주는 라이브러리를 함께 사용하지 않으면 많은 기반 코드를 작성해야 한다. (ReactiveCocoa, Rx 등)
        - VIPER의 라이터 역할에 해당하는 것이 없기 때문이다. 따라서 불필요한 의존성이 발생한다.
    - 간단한 observable 클래스만 갖춰도 MVC보다 낫다.

<br/>

**[출처: iOS 애플리케이션 아키텍처 - MVVM, MVC, VIPER 전격 비교](https://academy.realm.io/kr/posts/krzysztof-zablocki-mDevCamp-ios-architecture-mvvm-mvc-viper/)**